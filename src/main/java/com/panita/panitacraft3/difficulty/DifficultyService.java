package com.panita.panitacraft3.difficulty;

import com.panita.panitacraft3.difficulty.calculators.ChronologicDifficultyCalculator;
import com.panita.panitacraft3.difficulty.calculators.GroupDifficultyCalculator;
import com.panita.panitacraft3.difficulty.calculators.IndividualDifficultyCalculator;
import com.panita.panitacraft3.difficulty.util.DifficultyConfig;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * DifficultyService is a utility class that provides methods to calculate and manage the difficulty of the game.
 * It calculates global, group, and individual difficulties based on various parameters.
 */
public class DifficultyService {
    // Time in milliseconds to cache the chronologic difficulty
    private static final long CACHE_DURATION_MS = DifficultyConfig.getDifficultyCheckDelay();
    // The maximum difficulty value that can be returned
    public static final double FIXED_MAX_DIFFICULTY = DifficultyConfig.getMaxDifficultyScale();
    // The given difficulty multiplier for manual difficulty adjustments
    private static double MANUAL_DIFFICULTY_MULTIPLIER = DifficultyConfig.getManualMultiplier();

    // The cached chronologic difficulty value
    private static double cachedChronologicDifficulty = 0.0;
    // The last time the chronologic difficulty was calculated
    private static long lastChronologicCalculation = 0;
    // The cached individual difficulty values for players
    private static final Map<UUID, CachedDifficulty> individualDifficultyCache = new HashMap<>();

    public static double getChronologicDifficulty() {
        return getChronologicDifficulty(false);
    }

    /**
     * Evaluates the last cached chronologic difficulty and determines if it needs to be recalculated.
     * @param skipCache If true, forces a recalculation of the chronologic difficulty.
     * @return A number between 0 and the max fixed difficulty set representing the chronologic difficulty.
     */
    public static double getChronologicDifficulty(boolean skipCache) {
        if (!DifficultyConfig.isEnabled()) return 0;

        long now = System.currentTimeMillis();

        // Check if the cached chronologic difficulty is older than the cache duration
        if (!skipCache && (now - lastChronologicCalculation < CACHE_DURATION_MS)) {
            return cachedChronologicDifficulty;
        }

        double newValue = ChronologicDifficultyCalculator.calculate();
        cachedChronologicDifficulty = newValue;
        lastChronologicCalculation = now;
        return newValue;
    }

    /**
     * Calculates the difficulty of a group of players based on their individual difficulties.
     * @param location The location to calculate the group difficulty for.
     * @return A number between 0 and the max fixed difficulty set representing the group difficulty.
     */
    public static double getGroupDifficulty(Location location) {
        if (!DifficultyConfig.isEnabled()) return 0;
        return GroupDifficultyCalculator.calculate(location); // Calculate the group difficulty based on the players in the given location
    }

    public static double getAutoGeneratedDifficulty(Location context) {
        if (!DifficultyConfig.isEnabled()) return 0;

        double dg = getChronologicDifficulty();
        double dgp = getGroupDifficulty(context);
        int online = Bukkit.getOnlinePlayers().size();

        // Applies the following formula:
        // [(ChronologicDifficulty * 0.4) + (GroupDifficulty * 0.6)] * (1 + OnlinePlayers)
        return ((dg * DifficultyConfig.getChronologicWeight()) + (dgp * DifficultyConfig.getGroupWeight())) * (1 + online);
    }

    /**
     * Calculates the accumulated final difficulty using this formula
     * <br/> <code>[(Chronologic * 0.4) + (GroupDifficulty * 0.6)] * (1 + OnlinePlayers)</code>
     * @param context The location to calculate the group difficulty for.
     * @return A number that represents the total difficulty.
     */
    public static double getLocalDifficulty(Location context) {
        if (!DifficultyConfig.isEnabled()) return 0;

        double autoGeneratedDifficulty = getAutoGeneratedDifficulty(context); // Gets the auto-generated difficulty

        // Applies the following formula:
        // autoGeneratedDifficulty * manualMultiplier
        return autoGeneratedDifficulty * MANUAL_DIFFICULTY_MULTIPLIER; // Final difficulty can exceed the max fixed difficulty
    }

    /**
     * Calculates the difficulty of a player based on their individual difficulty.
     * @param player The player to calculate the difficulty for.
     * @return A number between 0 and the max fixed difficulty set representing the individual difficulty.
     */
    public static double getIndividualDifficulty(Player player) {
        if (!DifficultyConfig.isEnabled()) return 0;
        return getIndividualDifficulty(player, false); // Calculate the individual difficulty
    }

    /**
     * Calculates the difficulty of a player based on their individual difficulty.
     * @param player The player to calculate the difficulty for.
     * @param skipCache If true, forces a recalculation of the individual difficulty.
     * @return A number between 0 and the max fixed difficulty set representing the individual difficulty.
     */
    public static double getIndividualDifficulty(Player player, boolean skipCache) {
        UUID uuid = player.getUniqueId();
        long now = System.currentTimeMillis();

        if (!skipCache && individualDifficultyCache.containsKey(uuid)) {
            CachedDifficulty cached = individualDifficultyCache.get(uuid);
            if (now - cached.timestamp < CACHE_DURATION_MS) {
                return cached.value;
            }
        }

        double newValue = IndividualDifficultyCalculator.calculate(player);
        individualDifficultyCache.put(uuid, new CachedDifficulty(newValue, now));
        return newValue;
    }

    /**
     * Retrieves the manual difficulty multiplier.
     * @return The manual difficulty multiplier.
     */
    public static double getManualDifficultyMultiplier() {
        return MANUAL_DIFFICULTY_MULTIPLIER;
    }

    /**
     * Sets the manual difficulty multiplier.
     * @param multiplier The new manual difficulty multiplier.
     */
    public static void setManualDifficultyMultiplier(double multiplier) {
        MANUAL_DIFFICULTY_MULTIPLIER = Math.max(0, multiplier);
        DifficultyConfig.setDifficultyMultiplier(multiplier); // Save to config.yml
    }

    /**
     * Internal class that handles the caching of difficulty values
     * for the individual players.
     */
    private static class CachedDifficulty {
        double value;
        long timestamp;

        /**
         * Constructor for CachedDifficulty.
         * @param value The difficulty value to cache.
         * @param timestamp The timestamp when the difficulty was calculated.
         */
        CachedDifficulty(double value, long timestamp) {
            this.value = value;
            this.timestamp = timestamp;
        }
    }
}
